#!/usr/bin/env Rscript
library(optparse)
library(leafcutter)
library(ggplot2)
library(foreach)

arguments <- parse_args(OptionParser(usage = "%prog [options] counts_file groups_file cluster_significance_file", description="LeafCutter differential splicing plotting tool. Required inputs:\n <counts_file>: Intron usage counts file. Must be .txt or .txt.gz, output from clustering pipeline.\n <groups_file>: Two column file: 1. sample names (must match column names in counts_file), 2. groups (currently only two groups, i.e. pairwise, supported. Some samples in counts_file can be missing from this file, in which case they will not be included in the analysis. \n<cluster_significance_file> generated by leafcutter_ds.R",option_list=list(
  make_option(c("-o","--output"), default = "ds_plots.pdf", help="The output file  [default %default]"),
  make_option(c("-f","--plot_FDR"), default=0.01, help="FDR (in 0-1) below which to make plots  [default %default]"), 
  make_option(c("-m","--max_plots"), default=30, help="Maximum number of plots to create [default %default] "), 
  make_option(c("-e","--exon_file"), default=NULL, help="File defining known exons, example in data/gencode19_exons.txt.gz. Columns should be chr, start, end, strand, gene_name."))), 
  positional_arguments = 3)

opt=arguments$opt
counts_file=arguments$args[1]
groups_file=arguments$args[2]
cluster_significance_file=arguments$args[3]

cat("Loading counts from",counts_file,"\n")
if (!file.exists(counts_file)) stop("File ",counts_file," does not exist")
counts=read.table(counts_file, header=T, check.names=F, stringsAsFactors = F)

cat("Loading metadata from",groups_file,"\n")
if (!file.exists(groups_file)) stop("File ",groups_file," does not exist")
meta=read.table(groups_file, header=F, stringsAsFactors = F)
colnames(meta)=c("sample","group")

exon_table=if (!is.null(opt$exon_file)) {
  cat("Loading exons from",opt$exon_file,"\n")
  if (!file.exists(opt$exon_file)) stop("File ",opt$exon_file," does not exist")
  read.table(opt$exon_file, header=T, stringsAsFactors = F)
} else {
  cat("No exon_file provided.\n")
  NULL
}

counts=counts[,meta$sample]

meta$group=as.factor(meta$group)
group_names=levels(meta$group)

stopifnot(length(group_names)==2)

if (!file.exists(cluster_significance_file)) stop("File ",cluster_significance_file," does not exist")
cluster_table=read.table(cluster_significance_file, header=T, sep="\t", stringsAsFactors = F)

qvalues=leafcutter:::bh(cluster_table$p)
top_clus=cluster_table$cluster[ which(qvalues < opt$plot_FDR) ]

if (length(top_clus) > opt$max_plots) 
  top_clus=cluster_table$cluster[ order(qvalues)[seq_len(opt$max_plots)] ]

cat("Saving",length(top_clus),"plots to",opt$output,"\n")
introns=get_intron_meta(rownames(counts))
cluster_ids=paste( add_chr(introns$chr),introns$clu,sep = ":")


############################################
## ODK: copied source from leafcutter package and made local version

## Changed exons_chr = exons_table[exons_table == intron_meta$chr[1], ]
## to      exons_chr = exons_table[exons_table$chr == intron_meta$chr[1], ]
## This gave error when unintentional recycling had match in other column,
## e.g.:
## dat = data.frame(chr=c(1,1,1,2,2,2), other=c(10,10,10,1,10,10))
## dat[dat==2,] ## same as dat[dat$chr==2,]
## dat[dat==1,] ## not same as dat[dat$chr==1,]: has NA row

## Also: 
## changed digits from 0 to 1 (gave error for R 4.2.1, ggplot2_3.4.4)
## updated size to linewidth (gave error for R 4.2.1, ggplot2_3.4.4)

odk_make_differential_splicing_plot =
function (y, x = numeric(nrow(y)) + 1, exons_table = NULL, len = 500, 
          length_transform = function(g) log(g + 1), main_title = NA, 
          snp_pos = NA, summary_func = colMeans, legend_title = "Mean count") 
{
  intron_meta = get_intron_meta(colnames(y))
  new_theme_empty <- theme_bw(base_size = 16)
  new_theme_empty$line <- element_blank()
  new_theme_empty$rect <- element_blank()
  new_theme_empty$strip.text <- element_blank()
  new_theme_empty$axis.text <- element_blank()
  groups = sort(unique(x))
  max_log = 0.5 * ceiling(2 * log10(1 + max(unlist(foreach(tis = groups) %do% 
                                                     {
                                                       intron_meta$counts = summary_func(y[tis == x, , drop = F])
                                                     }))))
  breaks = if (max_log <= 2.5) 
    seq(0, max_log, by = 0.5)
  else seq(0, ceiling(max_log), by = 1)
  limits = c(0, max_log)
  intron_meta$id = as.factor(1:nrow(intron_meta))
  temp = intron_meta[, c("id", "start", "end")]
  m = reshape2::melt(temp, id.vars = "id")
  s = unique(m$value)
  if (!is.na(snp_pos)) 
    s = c(s, snp_pos)
  s = sort(s)
  d = s[2:length(s)] - s[1:length(s) - 1]
  trans_d = length_transform(d)
  coords = c(0, cumsum(trans_d))
  names(coords) = s
  snp_coord = coords[as.character(snp_pos)]
  total_length = sum(trans_d)
  my_xlim = c(-0.05 * total_length, 1.05 * total_length)
  message("total_length: ", total_length)
  message("my_xlim:", my_xlim[1], " ", my_xlim[2])
  message("s: ", toString(s))
  first_plot = T
  min_height = 0
  max_height = 0
  plots = foreach(tis = groups) %do% {
    print(tis)
    intron_meta$counts = summary_func(y[tis == x, , drop = F])
    group_sample_size = sum(tis == x)
    print(intron_meta$counts)
    allEdges = do.call(rbind, foreach(i = 1:nrow(intron_meta)) %do% 
                         {
                           if (intron_meta$counts[i] == 0) 
                             return(NULL)
                           start = coords[as.character(intron_meta$start[i])]
                           end = coords[as.character(intron_meta$end[i])]
                           l = end - start
                           h = (1 + sqrt(l)) * ((i%%2) * 2 - 1)
                           min_height = min(min_height, h)
                           max_height = max(max_height, h)
                           edge = data.frame(Hmisc::bezier(x = c(start, 
                                                                 start - 0.1 * total_length, (start + end)/2, 
                                                                 end + 0.1 * total_length, end), y = c(0, h * 
                                                                                                         2/3, h, h * 2/3, 0), evaluation = len))
                           edge$Sequence <- log10(1 + intron_meta$counts[i]) * 
                             sin(seq(0, pi, length.out = len))
                           edge$log10counts = log10(intron_meta$counts[i])
                           edge$Group <- i
                           edge
                         })
    #print("ODK: head(allEdges)")
    #print(head(allEdges))
    if (is.na(main_title) | !first_plot) 
      new_theme_empty$plot.title <- element_blank()
    first_plot = F
    g = ggplot(allEdges) + geom_path(aes(x = x, y = y, group = Group, 
                                         colour = log10counts, linewidth = Sequence, alpha = 0.9)) + 
      scale_size(breaks = breaks, labels = format(10^breaks, 
                                                  digits = 1), limits = limits, range = c(0.3, 
                                                                                          10), guide = guide_legend(title = legend_title)) + 
      scale_alpha(guide = "none", range = c(0.1, 1)) + 
      new_theme_empty + scale_color_gradient(breaks = breaks, 
                                             limits = limits, labels = format(10^breaks, digits = 1), 
                                             low = "blue", high = "red", guide = guide_legend(title = legend_title)) + 
      ylab(paste0(tis, " (n=", group_sample_size, ")")) + 
      xlab("") + xlim(my_xlim) + geom_hline(yintercept = 0, 
                                            alpha = 0.3)
    if (!is.na(snp_coord)) {
      df = data.frame(x = snp_coord, xend = snp_coord, 
                      y = 0, yend = max_height * 1.1)
      print(df)
      g = g + geom_segment(data = df, aes(x = x, y = y, 
                                          xend = xend, yend = yend))
    }
    g
  }
  df = data.frame(x = coords, xend = total_length * (s - min(s))/(max(s) - 
                                                                    min(s)), y = 0, yend = min_height)
  plots[[length(plots)]] = plots[[length(plots)]] + geom_segment(data = df, 
                                                                 aes(x = x, y = y, xend = xend, yend = yend), alpha = 0.1)
  if (!is.null(exons_table)) {
    # exons_chr = exons_table[exons_table == intron_meta$chr[1], ]
    ## ODK: changed line above --- it could result in NA row in exons_chr that causes error in invert_mapping step
    exons_chr = exons_table[exons_table$chr == intron_meta$chr[1], ]
    exons_here = exons_chr[(min(s) <= exons_chr$start & exons_chr$start <= 
                              max(s)) | (min(s) <= exons_chr$end & exons_chr$end <= 
                                           max(s)), ]
    
    if (F) {
      print("ODK debug")
      print(dim(exons_table))
      print(dim(intron_meta))
      print(dim(exons_chr))
      print(head(exons_table))
      print(head(intron_meta))
      print(head(exons_chr))
      print(summary(exons_chr$start))
      print(summary(exons_chr$end))
      print(exons_chr[is.na(exons_chr$start) | is.na(exons_chr$end),])
      print(summary(exon_table$start))
      print(summary(exon_table$end))
      print(table(is.na(exon_table$chr)))
      print(exons_here)
    }
    
    exons_here$gene_name = factor(exons_here$gene_name)
    gene_heights = min_height - ((1:length(levels(exons_here$gene_name))) - 
                                   1) * abs(min_height) * 0.15
    heights = gene_heights[as.numeric(exons_here$gene_name)]
    df = data.frame(x = total_length * (exons_here$start - 
                                          min(s))/(max(s) - min(s)), xend = total_length * 
                      (exons_here$end - min(s))/(max(s) - min(s)), y = heights, 
                    yend = heights)
    if (nrow(exons_here) > 0) 
      plots[[length(plots)]] = plots[[length(plots)]] + 
      geom_segment(data = df, aes(x = x, y = y, xend = xend, 
                                  yend = yend), alpha = 0.3, linewidth = 5) + geom_hline(yintercept = min_height, 
                                                                                    alpha = 0.3) + geom_text(data = data.frame(x = my_xlim[1], 
                                                                                                                               y = gene_heights, label = levels(exons_here$gene_name)), 
                                                                                                             aes(x, y, label = label))
    invert_mapping = function(pos) if (pos %in% s) 
      coords[as.character(pos)]
    else if (pos < min(s)) 
      my_xlim[1]
    else if (pos > max(s)) 
      my_xlim[2]
    else {
      w = which(pos < s[2:length(s)] & pos > s[1:(length(s) - 
                                                    1)])
      stopifnot(length(w) == 1)
      coords[w] + (coords[w + 1] - coords[w]) * (pos - 
                                                   s[w])/(s[w + 1] - s[w])
    }
    if (nrow(exons_here) > 0) {
      df = data.frame(x = sapply(exons_here$start, invert_mapping), 
                      xend = sapply(exons_here$end, invert_mapping), 
                      y = 0, yend = 0)
      for (i in 1:length(plots)) plots[[i]] = plots[[i]] + 
          geom_segment(data = df, aes(x = x, y = y, xend = xend, 
                                      yend = yend), alpha = 0.3, linewidth = 5)
    }
  }
  if (!is.na(main_title)) 
    plots[[1]] = plots[[1]] + ggtitle(main_title)
  do.call(gridExtra::grid.arrange, c(plots, list(ncol = 1)))
  if (!is.null(exons_table)) 
    exons_here
}


#############

pdf(opt$output, width=8, height=8)
for (clu in top_clus) {
  print(clu)
  y=t(counts[ cluster_ids==clu, ])
  odk_make_differential_splicing_plot(y, meta$group, exons_table=exon_table)
}
dev.off()

cat("All done, exiting\n")
